# 2225 - 합 분해
# 0 ~ N까지의 정수 K개를 더해 그 합이 N이 되는 경우의 수 모두 구하기
# 덧셈 순서도 고려함
# 수의 중복 가능(10 + 10 + 10같은 것이 가능)

# 1. 무식하게 접근
# K개의 정수를 k1, k2, k3..이라 할 때
# 각각의 수들에 1 ~ N까지의 수를 모두 집어넣어봄
# 마지막에 sum(K) == N이면 그 때만 카운트
# N = K = 200으로 주어지면 200^200만큼 연산을 해야함->시간초과가 날 것임

# 2. dp 또는 그리디로 해야 할 것 같다

# 2-1. 부분문제로 쪼갤 수 있는지?
# 0 ~ N까지의 정수 K개를 더해 그 합이 N이 되는 경우의 수
# =   첫 번째 수를 0으로 했을 때, 0 ~ N까지의 정수 K - 1개를 더해 그 합이 N이 되는 경우의 수
#   + 첫 번째 수를 1로 했을 때, 0 ~ N - 1까지의 정수 K - 1개를 더해 그 합이 N - 1이 되는 경우의 수
#   + 첫 번째 수를 2로 했을 때, 0 ~ N - 2까지의 정수 K - 1개를 더해 그 합이 N - 2이 되는 경우의 수
#   + ...
#   + 첫 번째 수를 N으로 했을 때, 0 ~ 0까지의 정수 K - 1개를 더해 그 합이 0이 되는 경우의 수

# 이런 식으로 쪼갤 수 있다.

# 2-2. 중복되는 구조가 있는지?
# 2차원 표를 그려보니 중복되는 것을 볼 수 있었음 -> dp로 풀이가 가능하다

# 3. 점화식의 형태
# dp[N][K] = dp[N][K - 1] + dp[N - 1][K - 1] + dp[N - 2][K - 1] + ... + dp[0][K - 1]

N, K = map(int, input().split())

mod = 1000000000

dp = [[0 for i in range(K + 1)] for j in range(N + 1)]

def solution(r, c):
    if dp[r][c]:
        return dp[r][c]

    if r == 0 or c == 1:
        dp[r][c] = 1
        return dp[r][c]
    
    for nr in range(r + 1):
        dp[r][c] = (dp[r][c] + solution(nr, c - 1)) % mod
    return dp[r][c]
    
print(solution(N, K))


# 옛날에 냅색문제 풀었을 때 2차원 표를 만들어서 풀이하는 걸 봤었는데 그게 도움이 된 것 같다
