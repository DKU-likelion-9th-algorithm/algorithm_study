# 1715 - 카드 정렬하기
# A장의 카드묶음과 B장의 카드묶음을 합치려면 A+B번의 비교를 함
# 여러 카드묶음들이 주어졌을 때, 모든 카드가 합쳐진 카드묶음을 만들때
# 비교횟수는 최소 몇?
# 카드묶음이 나열된 순서대로 좌->우로 가며 합치지 않음! 순서는 임의대로 할 수 있음

# 1. 무식하게 풀기
# 합치는 모든 경우를 탐색하며 최솟값 추출
# 카드 묶음 두 개당 하나의 결과카드묶음이 만들어지므로 카드묶음개수는 매 비교 시마다 하나씩 줄음
# nC2 * n-1C2 * n-2C2 * ... * 2C2번의 연산을 함
# n은 최대 100,000이므로 통과불가

# 2. dp나 그리디로 풀어야 할 것 같다.

# 2.1 부분문제로 쪼갤 수 있는지? O
# n개의 카드묶음에서 2개를 임의로 뽑고 합친 후,
# 뽑은 2개의 비교횟수 합 + n-1개의 카드묶음에서 낼 수 있는 최소비교횟수

# 중 가장 작은 값을 취하는 식으로 쪼갤 수 있는 것 같다. 잘 쪼갠건지는 모르겠다..

# 2.2 중복되는 구조가 있는지? 세모
# k개의 카드묶음 집합들이 있다고 할 때 카드묶음 구성이 같다면 중복된다고 볼 수 있음
# 그러나 이렇게 중복되는 경우가 항상 존재할지는 의문임. 가끔 중복되는 정도같다.

# 2.3 그리디..?
# 저번 주 문제들에서 그리디는 한 번의 선택들이 그 자체로 부분문제가 된다고 피드백 받았는데,
# 가만보니 이 문제가 한 번의 선택이 그 자체로 부분문제가 되는 경우에 해당한다는 느낌을 받았다.
# 그리디는 가장 ~~한 걸 뽑는거니까, 카드묶음 중에서
# 1) 가장 작은 묶음 2개
# 2) 가장 큰 묶음 2개
# 3) 가장 차이가 큰 묶음 2개
# 이런 식으로 해야할 것 같은데, 문제에서 주어진 예시에서 볼때 3은 아니고 1, 2 둘 중 하나일 것임

# 처음에 가장 작은 애들을 고른 경우를 포함하는 최적해가 있다.
# 가정 : 처음에 다른 조합를 고른 경우를 포함하는 최적해가 있던데?
# 반박 1) : 10, 20, 40의 조합이 있다고 하면 10 20부터 골라간 게 정답이고 이보다 작은 경우는 없다.
# 반박 2) 
#     n개의 카드묶음에 대해 비교는 항상 n-1번 일어난다. 
#     매 선택마다 제일 작은 카드묶음 2개를 골라 합쳐나갔을 때의 비교횟수 집합을
#     G = {g1, g2, g3, ..., g(n-1)} 이라 하고, 최적해의 비교횟수 집합을
#     O = {o1, o2, o3, ..., o(n-1)} 이라 한다. 이 때 G가 최적해가 아니라면
#     sum(G)와 sum(O)가 달라야하며 O가 최적해이므로 이론상 sum(O)가 더 작아야 하지만,
#     G는 매 순간 작은 카드들을 고른 비교횟수의 집합이므로 sum(G) < sum(O)가 되어 가정에 모순이다.
#     즉 G가 최적해이다

# 3. 정렬?
# 작은 애들부터 골라가야 하므로 카드묵음들을 처음에 오름차순으로 정렬
# 카드들을 합칠 때마다 새로운 카드묶음이 생김 -> 오름차순 유지를 위해 적절한 위치에 둬야 하는 경우가 생김
# 파이썬의 insert는 시간복잡도가 O(n)이므로 최악의 경우 O(n^2)정도의 연산을 하게 됨, 즉 매번 적절한 위치에
# 삽입하는 작업은 시간초과를 일으킨다. (n이 최대 100,000이므로)

# 4. 해결책 : heapq (우선순위 큐)
# 일반적인 큐 : FIFO를 만족함
# 우선순위 큐 : 들어간 순서 상관없이 우선순위가 높은 애들이 먼저 나옴. 이 문제에선 가장 작은 카드묶음에게
# 높은 우선순위가 있다고 하여 우선순위 큐를 사용 가능
# 파이썬에서 heapq의 pop : O(1), push : O(logN)
# 따라서 heapq를 활용할 때의 전체 시간복잡도는 O(NlogN)정도가 되며 100,000을 대입하면 대략 160만 정도의 연산
# 시간 내 통과 가능해짐

import heapq

N = int(input())

data = []

for _ in range(N):
    heapq.heappush(data, int(input()))

answer = 0

while len(data) != 1:
    min1 = heapq.heappop(data)
    min2 = heapq.heappop(data)
    heapq.heappush(data, min1 + min2)
    answer += (min1 + min2)

print(answer)
