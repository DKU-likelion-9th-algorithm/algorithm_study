'''
dp[n] = K(개)
dp[1] = 1개  : 1
dp[2] = 2개  : 11    00
dp[3] = 3개  : 111   001   100
dp[4] = 5개  : 1111  0011  1001  1100  0000
dp[n]은 (n-1번째 값들 맨끝에 1 붙이기 + n-2 번째 값들 맨 끝에 00붙이기) 한 갯수
dp[n] = dp[n-1] + dp[n-2]
'''

N = int(input())

dp = [0] * (N+2)
dp[1] = 1
dp[2] = 2

for n in range(3, N+1):
    dp[n] = (dp[n-1]+dp[n-2]) % 15746

print(dp[N])


'''
풀이 생각 과정
1차 :
# # #  N자리 수 ex) N = 3
_ 0 0
0 0 _
위처럼 00의 개수마다, 또는 위치마다 남는 자리에 1을 끼워넣을 생각을 했다.
계속 같은 수를 중복해 세기때문에 여태 센 수를 모두 저장해두고 중복됐나 찾아보면
엄청나게 반복을 많이 해야하기 때문에 이 방법은 아닐거라 생각했다.

2차 : 태홍님께서 알려주신대로 막무가내로 풀기와 전 값을 저장했다가 나중에 재활용하는 dp방법활용.
윗 풀이대로 했을때 7번째 줄에 적은 방법대로 풀면 되겠구나는 알겠는데
저걸 어떻게 풀어야할까 고민이었다. 계속 생각해보니 각각 숫자 뒤에 1붙이는 것과 00을 붙이는건
결국 dp[n]은 붙이는만큼의 갯수와 같으니 붙이는 만큼을 count하면 된다.
'''
